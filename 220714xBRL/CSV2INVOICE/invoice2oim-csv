#!/usr/bin/env python3
#coding: utf-8
#
# generate CSV from Open Peoopl e-Invoice (UBL 2.1)
#
# designed by SAMBUICHI, Nobuyuki (Sambuichi Professional Engineers Office)
# written by SAMBUICHI, Nobuyuki (Sambuichi Professional Engineers Office)
#
# MIT License
#
# (c) 2021-2022 SAMBUICHI Nobuyuki (Sambuichi Professional Engineers Office)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# from termios import VERASE
import xml.etree.ElementTree as ET
# import lxml.etree
import csv
import re
import sys
import os
import argparse
import collections
import json

from dic2etree import *

ET.register_namespace('', ns[''])
ET.register_namespace('xsd', ns['xsd'])
ET.register_namespace('xsi', ns['xsi'])
ET.register_namespace('cac', ns['cac'])
ET.register_namespace('cbc', ns['cbc'])
ET.register_namespace('qdt', ns['qdt'])
ET.register_namespace('udt', ns['udt'])
ET.register_namespace('ccts', ns['ccts'])
# ET.register_namespace('cn', ns['cn'])
ET.register_namespace('ubl', ns['ubl'])

SEP = os.sep
INVOICE = None  # '/ubl:Invoice'
LEADING_LENGTH = None  # 1+len(INVOICE) # /ubl:Invoice/
root = None

DocumentCurrencyCode = ''
TaxCurrencyCode = ''
SupplierTaxScheme = ''
uncl4451 = {}
pintList = []
pintDict = {}
pintSemSort = {}
pintMap = {}

bough0 = {'level': 0, 'id': 'ibg-00', 'count': ''}
boughs = {}
boughs[0] = [bough0]


def file_path(pathname):
    if SEP == pathname[0:1]:
        return pathname
    else:
        dir = os.path.dirname(__file__)
        new_path = os.path.join(dir, pathname)
        return new_path


def formatXPath(xpath):
    global id
    if re.match(r'.*\[cac:TaxScheme/cbc:ID.*\]', xpath):
        xpath = re.sub(r'\[cac:TaxScheme/cbc:ID[ ]*=[ ]*(.*)\]',
                       '/cac:TaxScheme[cbc:ID=\\1]/..', xpath)
        xpath = re.sub(r'\[cac:TaxScheme/cbc:ID[ ]*!=[ ]*(.*)\]',
                       '/cac:TaxScheme[cbc:ID!=\\1]/..', xpath)
        # if VERBOSE: print(f'formatXPath xpath={xpath}')
    if re.match(r'.*\[cbc:TaxAmount/@currencyID.*\]', xpath):
        if '/ubl:Invoice' == INVOICE:
            xpath = re.sub(r'\[cbc:TaxAmount/@currencyID[ ]*=[ ]*(.*)\]',
                           '/cbc:TaxAmount[@currencyID=\\1]/..', xpath)
            xpath = re.sub(r'/ubl:Invoice/cbc:DocumentCurrencyCode(/text\(\))?',
                           '"'+DocumentCurrencyCode+'"', xpath)
            if TaxCurrencyCode and re.match(r'.*/ubl:Invoice/cbc:TaxCurrencyCode(/text\(\))?', xpath):
                xpath = re.sub(
                    r'/ubl:Invoice/cbc:TaxCurrencyCode(/text\(\))?', '"'+TaxCurrencyCode+'"', xpath)
        elif '/Invoice' == INVOICE:
            xpath = re.sub(r'\[cbc:TaxAmount/@currencyID[ ]*=[ ]*(.*)\]',
                           '/cbc:TaxAmount[@currencyID=\\1]/..', xpath)
            xpath = re.sub(r'/Invoice/cbc:DocumentCurrencyCode(/text\(\))?',
                           '"'+DocumentCurrencyCode+'"', xpath)
            if TaxCurrencyCode and re.match(r'.*/Invoice/cbc:TaxCurrencyCode(/text\(\))?', xpath):
                xpath = re.sub(
                    r'/Invoice/cbc:TaxCurrencyCode(/text\(\))?', '"'+TaxCurrencyCode+'"', xpath)
            # if VERBOSE: print(f'formatXPath xpath={xpath}')
    if '/ubl:Invoice' == INVOICE:
        xpath = re.sub(r'/ubl:Invoice', '/{'+ns['ubl']+'}Invoice', xpath)
    elif '/Invoice' == INVOICE:
        xpath = re.sub(r'/Invoice', '/{'+ns['']+'}Invoice', xpath)
    # xpath = re.sub(r'/Invoice','/{'+ns['']+'}Invoice',xpath)
    xpath = re.sub(r'cac:', '{'+ns['cac']+'}', xpath)
    xpath = re.sub(r'cbc:', '{'+ns['cbc']+'}', xpath)
    if re.match(r'^.*/@[a-zA-Z]*$', xpath):
        path = re.sub(r'(.*)/@.*$', '\\1', xpath)
        attr = re.sub(r'.*/@(.*)$', '\\1', xpath)
        xpath = [path, attr]
    else:
        xpath = re.sub(r'false\(\)', "'false'", xpath)
        xpath = re.sub(r'true\(\)', "'true'", xpath)
        # if DEBUG: print(f'{getframeinfo(currentframe()).lineno:03d}: xpath={xpath}')
    return xpath


def updateBough(i, count):
    global rows
    global boughs
    global n
    data = pintList[i]
    id = data['id']
    BT = data['BT']
    level = boughLevel[id]
    if DEBUG:  # and id in ['ibg-17']:
        print(
            f'{getframeinfo(currentframe()).lineno:03d}: n={n:02d} i={i:03d} updateBough rows[{n}] {id} {rows[n]["0001"]}({rows[n]["0000"]})\n boughs[{n}] {boughs[n]}')
    n = len(rows) - 1
    bough = boughs[n]
    bough_id = bough[-1:][0]['id']
    parentList = parents[id]  # [1:]
    if parentList and len(parentList) > 0:
        if '-' == id[-2:-1]:
            parent_id = parentList[1:2][0]
            parent_BT = [v['BT']
                         for v in list(pintList) if parent_id == v['id']][0]
        else:
            parent_id = id
            parent_BT = BT
    else:
        parent_id = id
        parent_BT = BT
    if id in L1multipleBG or 'ibg-38' == id or n > 0:
        n = n + 1
    if n > 0:
        idx = n - 1
    else:
        idx = 0
    _boughs = boughs[idx]
    if 0 == len(parentList):
        _boughs = _boughs[:1]
    elif level < len(_boughs):
        _boughs = _boughs[:level]
    boughs[n] = _boughs + \
        [{'level': len(_boughs), 'id': parent_id, 'count': count}]
    rows[n] = {'0000': parent_id, '0001': parent_BT}
    if DEBUG:  # and id in ['ibg-16','ibg-17']:
        print(
            f'{getframeinfo(currentframe()).lineno:03d}: n={n:02d} i={i:03d} updateBough {id} rows[{n}] {rows[n]["0001"]}({rows[n]["0000"]})\n boughs[{n}] {boughs[n]}')


def fillData(parent, parentXPath, i, count):
    global n
    global id
    global boughs
    if None == parent:
        parent = root
    data = pintList[i]
    semSort = data['semSort']
    id = data['id']
    if id in Cardinality_Alignment_Attr:
        return i + 1
    level = data['level']
    BT = data['BT']
    xpath = data['xpath']
    if not xpath or len(xpath) < LEADING_LENGTH:
        return
    xpath = xpath[LEADING_LENGTH:]
    xpath = formatXPath(xpath)
    text = None
    try:
        if isinstance(xpath, list):
            element = None
            text = None
            if parentXPath:
                _xpath = xpath[0].replace(parentXPath+'/', '')
            else:
                _xpath = xpath[0]
            if re.match(r'^.*\[not\(.*\)\]', _xpath):
                # e.g. .*[not({urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2}DocumentTypeCode='130')]
                xpath_ = re.sub(r'^(.*)\[not\(.*\)\]', r'\1', _xpath)
                __xpath = re.sub(r'^(.*)\[not\((.*)\)\]', r'\1[\2]', _xpath)
                if parentXPath:
                    elements_ = parent.findall(xpath_)
                else:
                    elements_ = root.findall(xpath_)
                if len(elements_) > 0:
                    _elements = root.findall(__xpath)
                    elements = list(set(elements_)-set(_elements))
                    if len(elements) > 0:
                        text = elements[0].text
            else:
                element = parent.find(_xpath)
                # and ET.iselement(element):
                if not None == element and element.tag:
                    if isinstance(xpath, list) and xpath[1]:
                        attrib = xpath[1]
                        if attrib and attrib in element.attrib:
                            text = element.attrib[attrib]
                    else:
                        text = element.findtext('.')
        else:
            if re.match(r'^.*\[not\(.*\)\]', xpath):  # and re.match(r''):
                element = None
                text = None
                # e.g. .*[not({urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2}DocumentTypeCode='130')]
                xpath = formatXPath(xpath)
                if parentXPath:
                    _xpath = xpath.replace(parentXPath, '')[1:]
                else:
                    _xpath = xpath
                xpath_ = re.sub(r'^(.*)\[not\(.*\)\]', r'\1', _xpath)
                __xpath = re.sub(r'^(.*)\[not\((.*)\)\]', r'\1[\2]', _xpath)
                if parentXPath:
                    elements_ = parent.findall(xpath_)
                else:
                    elements_ = root.findall(xpath_)
                if len(elements_) > 0:
                    _elements = root.findall(__xpath)
                    elements = list(set(elements_)-set(_elements))
                    if len(elements) > 0:
                        text = elements[0].text
                    else:
                        element = parent.find(_xpath)
                        if None != element:
                            text = element.text
            else:
                if parentXPath and not 'TaxTotal' in xpath:
                    _xpath = xpath.replace(parentXPath+'/', '')
                else:
                    _xpath = xpath
                if 'TaxTotal' in _xpath and not 'TaxSubtotal' in _xpath:
                    text = root.findtext(_xpath)
                elif 'TaxSubtotal' in _xpath:
                    _xpath = xpath.replace(parentXPath+'/', '')
                    text = parent.findtext(_xpath)
                    if not text:
                        text = root.findtext(
                            parentXPath+'['+str(n)+']/'+_xpath)
                else:
                    if not id in Cardinality_Alignment:
                        text = parent.findtext(_xpath)
                        # if not text:
                        #   text = root.findtext(_xpath)
                    else:
                        elements = parent.findall(_xpath)
                        if len(elements) == 1:
                            text = parent.findtext(_xpath)
                        elif len(elements) > 1:
                            attr_i = None
                            next_i = None
                            for count in range(len(elements)):
                                element = elements[count]
                                text = element.text
                                text = text.strip().replace('\n', '\\n')
                                rows[n][semSort] = {
                                    'id': id, 'level': level, 'BT': BT, 'text': text}
                                elementName = re.sub(
                                    r'^.*}([a-zA-Z]*)$', r'\1', _xpath)
                                attr = element.attrib
                                ks = [x for x in attr.keys()]
                                for k in ks:
                                    attrName = elementName+'/@'+k
                                    d = [v for k, v in pintDict.items(
                                    ) if attrName in v['xpath']][0]
                                    semSort_ = d['semSort']
                                    id_ = d['id']
                                    BT_ = d['BT']
                                    text_ = attr[k]
                                    text_ = text_.strip().replace('\n', '\\n')
                                    rows[n][semSort_] = {'id': id_, 'level': str(
                                        int(level)+1), 'BT': BT_, 'text': text_}
                                    for i_ in range(len(pintList)):
                                        d = pintList[i_]
                                        if semSort_ == d['semSort']:
                                            attr_i = i_
                                            break
                                if attr_i:
                                    i = attr_i
                            i += 1
    except SyntaxError:
        print(f'-- SyntaxError {_xpath}')
    if text:
        if re.match(r'ibg-', id):
            text = ''
        elif 'ibt-021' == id:
            key = text.strip()
            if key in uncl4451.keys():
                text = key
            else:
                text = ''
        elif 'ibt-022' == id and text.strip() in uncl4451.keys():
            text = ''
        text = text.strip().replace('\n', '\\n')
        rows[n][semSort] = {'id': id, 'level': level, 'BT': BT, 'text': text}
        if DEBUG:
            print(
                f'{getframeinfo(currentframe()).lineno:03d}: n={n:02d} i={i:03d} * {rows[n][semSort]}')
    return i + 1


def fillGroup(parent, parentPath, i, parentCount):
    global n
    global id
    # if DEBUG:
    #   print(f'{getframeinfo(currentframe()).lineno:03d}: n={n:02d} i={i:03d} - fillGroup boughs[{n}]={boughs[n]}')
    data = pintList[i]
    id = data['id']
    level = data['level']
    BT = data['BT']
    xpath = data['xpath']
    if DEBUG:
        print(
            f'{getframeinfo(currentframe()).lineno:03d}: n={n:02d} i={i:03d} - fillGroup {BT}({id})')
    if not xpath or len(xpath) < LEADING_LENGTH:
        return i + 1
    while i < len(pintList):
        data = pintList[i]
        id = data['id']
        level = data['level']
        BT = data['BT']
        xpath = data['xpath']
        xpath = xpath[LEADING_LENGTH:]
        xpath = formatXPath(xpath)
        if parentPath:
            _xpath = xpath.replace(parentPath+'/', '')
        else:
            _xpath = xpath

        if re.match(r'ibt-', id):
            return None
        elif re.match(r'ibg-', id):
            try:
                elements = None
                if re.match(r'^.*\[not\(.*\)\]', _xpath):
                    # e.g. .*[not({urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2}DocumentTypeCode='130')]
                    xpath_ = re.sub(r'^(.*)\[not\(.*\)\]', r'\1', _xpath)
                    __xpath = re.sub(
                        r'^(.*)\[not\((.*)\)\]', r'\1[\2]', _xpath)
                    if parentPath:
                        elements_ = parent.findall(xpath_)
                        _elements = parent.findall(__xpath)
                    else:
                        elements_ = root.findall(xpath_)
                        _elements = root.findall(__xpath)
                    elements = list(set(elements_)-set(_elements))
                else:
                    if 'InvoicePeriod' in xpath:
                        if 'InvoiceLine' in xpath:
                            elements = parent.findall(_xpath)
                        else:
                            elements = root.findall(_xpath)
                    elif 'Contact' in xpath:
                        elements = root.findall(_xpath)
                    elif parentPath:
                        elements = parent.findall(_xpath)
                    else:
                        elements = root.findall(_xpath)
            except SyntaxError:
                print(f'-- SyntaxError {data["xpath"]}')

            if not elements or 0 == len(elements):
                return i + 1
            next_i = None
            # ibg-30:LINE TAX INFORMATION
            if len(elements) > 1 or id in ['ibg-23', 'ibg-38', 'ibg-25', 'ibg-27', 'ibg-28', 'ibg-32']:
                # ibg-23:TAX BREAK DOWN
                # ibg-38:TAX BREAKDOWN IN ACCOUNTING CURRENCY
                # ibg-25:INVOICE LINE
                # ibg-27:INVOICE LINE ALLOWANCE
                # ibg-28:INVOICE LINE CHARGE
                # ibg-32:ITEM ATTRIBUTES
                # print(boughs[n][-1])
                count = 0
                updateBough(i, count)
            else:
                count = ''
                if not id in ['ibg-32', 'ibt-160', 'ibt-161']:
                    # ibg-32:ITEM ATTRIBUTES
                    # ibt-160:Item attribute name
                    # ibt-161:Item attribute value
                    n = len(rows) - 1
                if id in L12_single_BTG + L1multipleBG:
                    n = 0
                if parents[id][-1] != [x['id'] for x in boughs[n]][-1]:
                    current_bough = [[x['id'], x['level']]
                                     for x in boughs[n]]  # [1:-1][-1]
                    if len(current_bough) > 1:
                        if len(current_bough) == 2:
                            current_bough_ = current_bough[-1]
                        else:
                            current_bough_ = current_bough[1:-1][-1]
                        for index, bough_ in boughs.items():
                            if len(bough_) == 2:
                                bough_1 = bough_[1]
                                # print(current_bough_,bough_1)
                                if current_bough_[0] == bough_1['id'] and current_bough_[1]-1 == bough_1['count']:
                                    n = index
            for element in elements:
                if isinstance(count, int) and count > 0 and count < len(elements):
                    updateBough(i, count)
                _i = i + 1
                _data = pintList[_i]
                _id = _data['id']
                _level = _data['level']
                _BT = _data['BT']
                if DEBUG:
                    id = pintList[i]['id']
                    print(
                        f'{getframeinfo(currentframe()).lineno:03d}: n={n:02d} i={_i:03d} - fillGroup -check- {BT}({id})[{count}] -> {_BT}({_id})')
                while _level > level and _i < len(pintList):
                    next_i = None
                    if re.match(r'^ibg-', _id):
                        next_i = fillGroup(element, xpath, _i, count)
                    elif re.match(r'^ibt-', _id):
                        if _id in L12_single_BTG:
                            n = 0
                        next_i = fillData(element, xpath, _i, count)
                    if next_i:
                        if next_i < len(pintList):
                            next_data = pintList[next_i]
                            _id = next_data['id']
                            _level = next_data['level']
                            _i = next_i
                        if next_i == len(pintList):
                            _i = next_i
                    else:
                        _i += 1
                if isinstance(count, int):
                    count += 1
            if next_i:
                i = next_i
                next_i = None
            else:
                i = _i + 1
            return i


if __name__ == '__main__':
    # Create the parser
    parser = argparse.ArgumentParser(prog='invoice2csv',
                                     usage='%(prog)s [options] infile -o outfile -e encoding',
                                     description='電子インボイスXMLファイルをCSVファイルに変換')
    # Add the arguments
    parser.add_argument('inFile', metavar='infile', type=str, help='入力XMLファイル')
    parser.add_argument('-o', '--outfile')
    parser.add_argument('-s', '--source')
    parser.add_argument('-e', '--encoding')  # 'Shift_JIS' 'cp932' 'utf_8'
    parser.add_argument('-v', '--verbose', action='store_true')
    parser.add_argument('-d', '--debug', action='store_true')

    args = parser.parse_args()
    in_file = None
    if args.inFile:
        in_file = args.inFile.strip()
        in_file = in_file.replace('/', SEP)
        in_file = file_path(args.inFile)
    # Check if infile exists
    if not in_file or not os.path.isfile(in_file):
        print('入力ファイルがありません')
        sys.exit()
    else:
        with open(in_file) as infile:
            s = infile.read()
            if '<ubl:Invoice' in s:
                INVOICE = '/ubl:Invoice'
            elif '<Invoice' in s:
                INVOICE = '/Invoice'
            LEADING_LENGTH = 1+len(INVOICE)
    pint_file = None
    if args.source:
        pint_file = args.source.lstrip()
        pint_file = pint_file.replace('/', SEP)
        pint_file = file_path(pint_file)
    # Check if PINT exists
    if not pint_file or not os.path.isfile(pint_file):
        print('PINTファイルがありません')
        sys.exit()
    pre, ext = os.path.splitext(in_file)
    if args.outfile:
        out_file = args.outfile.lstrip()
        out_file = out_file.replace('/', SEP)
        out_file = file_path(out_file)
    else:
        out_file = pre+'.csv'
    pre, ext = os.path.splitext(out_file)
    metadata_file = pre+'-metadata.json'
    oim_file = pre+'-oim.csv'
    tmp_file = pre+'.txt'
    ncdng = args.encoding
    if ncdng:
        ncdng = ncdng.lstrip()
    else:
        ncdng = 'UTF-8'
    VERBOSE = args.verbose
    DEBUG = args.debug
    if DEBUG:
        from inspect import currentframe, getframeinfo

    if VERBOSE:
        print(f'** START ** {__file__}')
        print(f'-- Input file {in_file}')

    L12_single_BTG = ['ibt-006', 'ibt-007', 'ibt-008', 'ibt-009', 'ibt-010', 'ibt-011', 'ibt-012', 'ibt-013', 'ibt-014', 'ibt-015', 'ibt-016', 'ibt-017', 'ibt-018', 'ibt-018-1', 'ibt-019', 'ibg-02', 'ibt-023', 'ibt-024', 'ibg-04', 'ibt-027', 'ibt-028', 'ibt-029', 'ibt-029-1', 'ibt-090', 'ibt-090-1', 'ibt-030', 'ibt-030-1', 'ibt-031', 'ibt-032', 'ibt-032-1', 'ibt-033', 'ibt-034', 'ibt-034-1', 'ibg-05', 'ibt-035', 'ibt-036', 'ibt-162', 'ibt-037', 'ibt-038', 'ibt-039', 'ibt-040', 'ibg-06', 'ibt-041', 'ibt-042', 'ibt-043', 'ibg-07', 'ibt-044', 'ibt-045', 'ibt-046', 'ibt-046-1', 'ibt-047', 'ibt-047-1', 'ibt-048', 'ibt-048-1', 'ibt-049',
                      'ibt-049-1', 'ibg-08', 'ibt-050', 'ibt-051', 'ibt-163', 'ibt-052', 'ibt-053', 'ibt-054', 'ibt-055', 'ibg-09', 'ibt-056', 'ibt-057', 'ibt-058', 'ibg-10', 'ibt-059', 'ibt-060', 'ibt-060-1', 'ibt-061', 'ibt-061-1', 'ibg-11', 'ibt-062', 'ibt-063', 'ibt-063-1', 'ibg-12', 'ibt-064', 'ibt-065', 'ibt-164', 'ibt-066', 'ibt-067', 'ibt-068', 'ibt-069', 'ibg-13', 'ibt-070', 'ibt-071', 'ibt-071-1', 'ibt-072', 'ibg-14', 'ibt-073', 'ibt-074', 'ibg-15', 'ibt-075', 'ibt-076', 'ibt-165', 'ibt-077', 'ibt-078', 'ibt-079', 'ibt-080', 'ibg-22', 'ibt-106', 'ibt-107', 'ibt-108', 'ibt-109', 'ibt-110', 'ibt-111', 'ibt-112', 'ibt-113', 'ibt-114', 'ibt-115']
    L2_multiple_BG = ['ibg-17', 'ibt-084', 'ibt-085', 'ibt-086']

    # Cardinality alignment for Party tax scheme, Party identification, and Commodity classification
    Cardinality_Alignment = ['ibt-029', 'ibt-031',
                             'ibt-047', 'ibt-048', 'ibt-158']
    Cardinality_Alignment_Attr = ['ibt-158-1', 'ibt-158-2']

    TaxAccounting = ['ibg-37', 'ibt-111', 'ibg-38', 'ibt-190', 'ibt-192', 'ibt-193',
                     'ibt-194', 'ibt-195', 'ibt-199', 'igb-23', 'ibt-116', 'ibt-117', 'ibt-118', 'ibt-119']

    uncl4451_file = file_path('data/common/uncl4451.txt')
    with open(uncl4451_file, encoding='utf-8', newline='') as uncl4451file:
        reader = csv.reader(uncl4451file, delimiter='|', quoting=csv.QUOTE_NONE)
        n = 0
        for v in reader:
            id = v[0]
            name = v[1]
            desc = v[2]
            uncl4451[id] = {'id': id, 'name': name, 'desc': desc}
            n += 1

    tree = ET.parse(in_file)
    # tree = lxml.etree.parse(in_file)
    root = tree.getroot()
    invoiceNumber = root.findtext(".//{"+ns['cbc']+"}ID")
    invoiceIssueDate = root.findtext(".//{"+ns['cbc']+"}IssueDate")
    DocumentCurrencyCode = root.findtext(".//{"+ns['cbc']+"}DocumentCurrencyCode")
    TaxCurrencyCode = root.findtext(".//{"+ns['cbc']+"}TaxCurrencyCode")
    SupplierTaxScheme = root.findtext(".//{"+ns['cac']+"}AccountingSupplierParty/{"+ns['cac']+"}Party/{"+ns['cac']+"}PartyTaxScheme/{"+ns['cac']+"}TaxScheme/{"+ns['cbc']+"}ID")

    # SemSort,ID,Section,PINTCard,Aligned,AlignedCard,Level,BT,BT_ja,DT,Desc,Desc_ja,Explanation,Explanation2,Example,SyntSort,element,UBLdatatype,XPath,selectors,Codelist,SyntaxCard,UBLOccurrence,CAR
    # 0       1  2       3        4       5           6     7  8     9  10   11      12          13           14      15       16      17          18    19        20       21         22            23
    COL_SemanticSort = 0
    COL_ID = 1
    COL_level = 6
    COL_BT = 7
    COL_card = 5
    COL_datatype = 9
    COL_SyntaxSort = 15
    COL_xpath = 18
    if VERBOSE:
        print(f'-- PINT file {pint_file}')
    with open(pint_file, encoding=ncdng, newline='') as pintfile:
        reader = csv.reader(pintfile)  # ,delimiter='\t')
        header = next(reader)
        for v in reader:
            id = v[COL_ID].strip()
            if id:  # and 'ibt-032'!=id:
                xpath = v[COL_xpath]
                # re.match(r'^\/Invoice\/ext:UBLExtensions',xpath):
                if re.match(r'^/(ubl:)?Invoice$', xpath):
                    continue
                syntaxSort = v[COL_SyntaxSort]
                if not syntaxSort:
                    syntaxSort = '9999'
                if not xpath:
                    xpath = '/'+id
                if len(v) > COL_xpath and '/' in xpath:
                    if '/ubl:Invoice' == INVOICE:
                        if re.match(r'/ubl:Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID=/ubl:Invoice/cbc:DocumentCurrencyCode(/text\(\))?]', xpath):
                            xpath = '/ubl:Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID="' + \
                                DocumentCurrencyCode+'"]'
                        elif re.match(r'/ubl:Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID=/ubl:Invoice/cbc:TaxCurrencyCode(/text\(\))?]', xpath):
                            if TaxCurrencyCode and id in TaxAccounting:
                                xpath = '/ubl:Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID="' + \
                                    TaxCurrencyCode+'"]'
                            else:
                                continue
                    elif '/Invoice' == INVOICE:
                        if re.match(r'/Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID=/Invoice/cbc:DocumentCurrencyCode(/text\(\))?]', xpath):
                            xpath = '/Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID="' + \
                                DocumentCurrencyCode+'"]'
                        elif re.match(r'/Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID=/Invoice/cbc:TaxCurrencyCode(/text\(\))?]', xpath):
                            if TaxCurrencyCode and id in TaxAccounting:
                                xpath = '/Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID="' + \
                                    TaxCurrencyCode+'"]'
                            else:
                                continue
                    semanticSort = v[COL_SemanticSort]
                    if v[COL_BT]:
                        BT = v[COL_BT]
                    else:
                        BT = None
                    level = v[COL_level]
                    card = ''+v[COL_card].strip()
                    datatype = ''+v[COL_datatype].strip()
                    data = {'semSort': semanticSort, 'id': id, 'level': level,
                            'BT': BT, 'card': card, 'datatype': datatype, 'xpath': xpath}
                    pintList.append(data)
                    pintDict[semanticSort] = data
                    pintSemSort[id] = semanticSort
                    pintMap[id] = data

    # https://www.geeksforgeeks.org/ways-sort-list-dictionaries-values-python-using-itemgetter/
    # https://www.delftstack.com/ja/howto/python/sort-list-of-lists-in-python/
    sorted_rows = sorted(pintList, key=lambda x: x['semSort'])
    pintList = sorted_rows

    idxLevel = {}
    idxLevel = []
    parents = {}
    for i in range(len(pintList)):
        data = pintList[i]
        level = int(data['level'])
        id = data['id']
        num = id
        parent = id
        if level > 0:
            parent = idxLevel[:level]  # .reverse()
            # parent = parent.reverse()
        while level > len(idxLevel) - 1:
            idxLevel.append('')
        idxLevel[level] = num
        parents[id] = parent

    L1multipleBG = [x['id'] for x in pintList if '1' == x['level']
                    and re.match(r'ibg-', x['id']) and 'n' == x['card'][3:]]
    L2multipleBG = [x['id'] for x in pintList if '2' == x['level']
                    and re.match(r'ibg-', x['id']) and 'n' == x['card'][3:]]
    bLevel = [{'id': v['id'], 'level':v['level']}
              for v in pintList if 'ibg' == v['id'][:3] and 'n' == v['card'][-1:]]
    boughLevel = {}
    for d in bLevel:
        boughLevel[d['id']] = int(d['level'])
    boughLevel['ibg-32'] = 2

    n = 0
    rows = {}
    rows[n] = {'0000': 'ibg-00', '0001': 'CONTENT'}
    boughs[n] = [{'level': 0, 'id': 'ibg-00', 'count': ''}]
    parent_xpath = None
    count = ''
    i = 0
    next_i = None
    boughLvl = 1
    while i < len(pintList):
        data = pintList[i]
        semSort = data['semSort']
        id = data['id']
        if not TaxCurrencyCode and id in TaxAccounting:
            i += 1
            continue
        if id in Cardinality_Alignment_Attr:
            i += 1
            continue
        BT = data['BT']
        level = data['level']
        xpath = data['xpath']
        if DEBUG:
            print(
                f'{getframeinfo(currentframe()).lineno:03d}: n={n:02d} pintList[{i}] {BT}({id})')
        if re.match(r'^ibt-', id):
            i = fillData(None, '', i, None)
        elif re.match(r'^ibg-', id):
            i = fillGroup(None, '', i, None)

    checkedParents = []
    for id in rows[0].keys():
        if re.match(r'^ibg-', id):
            if not id in checkedParents:
                checkedParents.append(id)

    checkedData = []
    for k, v in rows.items():
        for semanticSort, data in v.items():
            if semanticSort < '1000':
                continue
            id = data['id']
            parentIDs = parents[id]  # [1:]
            for parentID in parentIDs:
                if re.match(r'ibg-', parentID) and not parentID in checkedData and not parentID in checkedParents:
                    semanticSort = pintSemSort[parentID]
                    data = {'id': parentID, 'semanticSort': semanticSort}
                    if not data in checkedData:
                        checkedData.append(data)

    for parent in checkedData:
        id = parent['id']
        semanticSort = parent['semanticSort']
        data = pintDict[semanticSort]
        if not semanticSort in rows[0].keys():
            rows[0][semanticSort] = {
                'id': data['id'], 'level': data['level'], 'BT': data['BT'], 'text': ''}

    maxBoughLvl = 1
    for n, data in boughs.items():
        for bough in data:
            level = int(bough['level'])
            if level > maxBoughLvl:
                maxBoughLvl = level

    checkedParents = []
    for id in rows[0].keys():
        if re.match(r'^ibg-', id):
            if not id in checkedParents:
                checkedParents.append(id)

    checkedData = []
    for k, v in rows.items():
        for semanticSort, data in v.items():
            if semanticSort < '1000':
                continue
            id = data['id']
            parentIDs = parents[id]  # [1:]
            for parentID in parentIDs:
                if re.match(r'ibg-', parentID) and not parentID in checkedData and not parentID in checkedParents:
                    semanticSort = pintSemSort[parentID]
                    data = {'id': parentID, 'semanticSort': semanticSort}
                    if not data in checkedData:
                        checkedData.append(data)

    for parent in checkedData:
        id = parent['id']
        semanticSort = parent['semanticSort']
        data = pintDict[semanticSort]
        if not semanticSort in rows[0].keys():
            rows[0][semanticSort] = {
                'id': data['id'], 'level': data['level'], 'BT': data['BT'], 'text': ''}

    maxBoughLvl = 1
    for n, data in boughs.items():
        for bough in data:
            level = int(bough['level'])
            if level > maxBoughLvl:
                maxBoughLvl = level

    bough_rows = {}
    for n in rows.keys():
        bough_rows[n] = {}
        m = 0
        for bough in boughs[n]:
            level = int(bough['level'])
            id = bough['id']
            if 'ibg-00' == id:
                BT = 'INVOICE'
            else:
                semSort = pintSemSort[id]
                data = pintDict[semSort]
                BT = data['BT']
            count = str(bough['count'])
            bough_rows[n]['000'+str(3*level)] = id
            bough_rows[n]['000'+str(1+3*level)] = BT
            bough_rows[n]['000'+str(2+3*level)] = count
            m += 1
        for i in range(maxBoughLvl-m):
            bough_rows[n]['000'+str(3*(m+i))] = ''
            bough_rows[n]['000'+str(1+3*(m+i))] = ''
            bough_rows[n]['000'+str(2+3*(m+i))] = ''
        # if DEBUG:
        #   print(f'{getframeinfo(currentframe()).lineno:03d}: n={n:02d} bough_rows[{n}] {bough_rows[n]}')

    for n, row in rows.items():
        for semSort, data in row.items():
            if int(semSort) < 1000:
                continue
            bough_rows[n][semSort] = data

    max_col = len(bough_rows)
    transposed = {}
    lookup = {}
    index = 0
    for col, row in bough_rows.items():
        for semSort, data in row.items():
            if not semSort in transposed:
                transposed[semSort] = {}
                if semSort in pintDict:
                    d = pintDict[semSort]
                    transposed[semSort][0] = d['id']
                    transposed[semSort][1] = d['level']
                    transposed[semSort][2] = d['card']
                    transposed[semSort][3] = d['BT']
                else:
                    transposed[semSort][0] = ''
                    transposed[semSort][1] = ''
                    transposed[semSort][2] = ''
                    transposed[semSort][3] = ''
            if int(semSort) < 1000:  # when'0000'==semSort or '0001'==semSort:
                transposed[semSort][4+col] = data
            elif data['text']:
                transposed[semSort][4+col] = data['text']

    od_transposed = collections.OrderedDict(sorted(transposed.items()))

    del_list = []
    for semSort, data in od_transposed.items():
        check = ''
        for k, v in data.items():
            if k > 3:
                check += v
        if not check and not re.match(r'^ibg-', data[0]):
            del_list.append(semSort)

    for semSort in del_list:
        del transposed[semSort]

    max_col += 4
    lst = []
    i = 0
    for row in od_transposed:
        lst.append(['']*max_col)
    i = 0
    for semSort, data in od_transposed.items():
        for j in range(max_col):
            if j in od_transposed[semSort]:
                lst[i][j] = od_transposed[semSort][j]
        i += 1

    with open(out_file, 'w', encoding='utf-16') as outfile:
        writer = csv.writer(outfile)  # ,delimiter='\t')
        n = 0
        for l in lst:
            if n < 3:
                n += 1
                continue
            writer.writerow(l)
    if VERBOSE:
        print(f'-- out_file {out_file}')

    max_x = len(lst[0])
    h = 0
    while '' == lst[h][0]:
        h += 1
    max_h = int(h/3)
    max_y = len(lst) - max_h
    num_d = 0
    header = []
    records = []
    for x in range(4, max_x):
        for h in range(max_h):
            k = lst[3*h+0][x]
            if k and not k in header:
                header.append(k)
                num_d += 1
    for y in range(3*max_h, max_y):
        k = lst[y][0]
        if not k in header:
            header.append(k)
    print(header)
    for x in range(4, max_x):
        record = {}
        for i in range(len(header)):
            record[header[i]] = ''
        for h in range(max_h):
            k = lst[3*h+0][x]
            v = lst[3*h+2][x]
            if v:
                record[k] = v
        for y in range(3*max_h, max_y):
            k = lst[y][0]
            v = lst[y][x]
            if v:
                record[k] = v
        records.append(record)

    keys = {}
    for record in records:
        for d in range(num_d):
            id = header[d]
            if id and record[id] and record[id] > '0':
                keys[id] = 'multiple'
            else:
                keys[id] = ''
    oimMap = {}
    for record in records:
        record_length = len(record)
        for i in range(num_d):
            id = header[i]
            if 'multiple' == keys[id]:
                v = record[id]
                v = str(1 + int(v))
                record[id] = v
            else:
                record[id] = ''
        index = '_'.join(list(record.values())[:num_d])
        for i in range(num_d, record_length):
            id = header[i]
            if record[id]:
                if not index in oimMap:
                    oimMap[index] = {}
                if not id in oimMap[index]:
                    oimMap[index][id] = {}
                if record[id]:
                    oimMap[index][id] = record[id]

    records = []
    for k, r in oimMap.items():
        record = {}
        for id in header:
            record[id] = ''
            indexes = k.split('_')
        i = 0
        for index in indexes:
            id = header[i]
            record[id] = index
            i += 1
        for k, v in r.items():
            record[k] = v
        record['ibg-00'] = invoiceNumber
        records.append(record)
    # if DEBUG:
    #     print(records)
    with open(oim_file, 'w', newline='') as oimfile:
        writer = csv.DictWriter(oimfile, fieldnames=header)
        writer.writeheader()
        writer.writerows(records)
    if VERBOSE:
        print(f'-- OIM CSV {oim_file}')

    metadata = {
        "documentInfo": {
            "documentType": "https://xbrl.org/2021/xbrl-csv",
            "namespaces": {
                "pint": "http://www.xbrl.jp/eipa/peppol/0.9",
                "ns0": "http://www.example.com",
                "link": "http://www.xbrl.org/2003/linkbase",
                "iso4217": "http://www.xbrl.org/2003/iso4217",
                "xsi": "http://www.w3.org/2001/XMLSchema-instance",
                "xbrli": "http://www.xbrl.org/2003/instance",
                "xbrldi": "http://xbrl.org/2006/xbrldi",
                "xlink": "http://www.w3.org/1999/xlink"
            },
            "taxonomy": [
                "core.xsd"
            ],
        },
        "tableTemplates": {
            "pint": {
                "columns": {

                },
                "dimensions": {
                    "pint:_380": "$G00",
                    "period": "",
                    "entity": "ns0:Example co."
                }
            }
        },
        "tables": {
            "pint": {
                "url": ""
            }
        }
    }

    for id in header:
        if re.match(r'^ibg-[0-9]*$',id):
            ID = 'G'+id[4:]
            metadata['tableTemplates']['pint']['columns'][ID] = {}
            metadata['tableTemplates']['pint']['dimensions'][f"pint:{ID}"] = f"${ID}"
        else:
            d = pintMap[id]
            if d['datatype'] in ['Amount', 'Unit price Amount']:
                metadata['tableTemplates']['pint']['columns'][id] = {
                    'decimals': 'INF',
                    'dimensions': {
                        'concept': f'pint:{id}',
                        'unit': f'iso4217:{DocumentCurrencyCode}' # TODO TaxCurrencyCode
                    }
                }
            else:
                metadata['tableTemplates']['pint']['columns'][id] = {
                    'dimensions': {
                        'concept': f'pint:{id}',
                    }
                }
    metadata['tableTemplates']['pint']['dimensions']['period'] = f'{invoiceIssueDate}T00:00:00'
    metadata['tables']['pint']['url'] = os.path.basename(oim_file)

    with open(metadata_file, 'w') as metadatafile:
        json.dump(metadata, metadatafile, indent=4)
    if VERBOSE:
        print(f'-- metadata {metadata_file}')
    
    print('** END')
